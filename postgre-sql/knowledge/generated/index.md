[返回](/postgre-sql/knowledge/index)

# PostgreSQL 中的 GENERATED 语法详解

在 PostgreSQL 中，`GENERATED` 语法主要有两种使用方式，其中 `GENERATED ALWAYS` 是最常见的，但也存在不跟 `ALWAYS` 的情况。

## 1. GENERATED ALWAYS 与 GENERATED BY DEFAULT 的区别

PostgreSQL 中 `GENERATED` 可以搭配两种关键字：

### 1.1 GENERATED ALWAYS（推荐使用）

```sql
CREATE TABLE products (
    id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL
);
```

### 1.2 GENERATED BY DEFAULT

```sql
CREATE TABLE products (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL
);
```

## 2. 主要区别
```
| 特性                | GENERATED ALWAYS                 | GENERATED BY DEFAULT             |
|---------------------|----------------------------------|----------------------------------|
| 自动生成值          | 必须由系统生成                   | 可以由系统生成或手动指定         |
| 插入时指定值        | 不允许（除非使用 OVERRIDING）    | 允许                             |
| 安全性              | 更高（防止人工干预）             | 较低（允许人工干预）             |
| 使用场景            | 需要严格控制的序列值             | 需要灵活插入的场景               |
```
## 3. 具体使用示例

### 3.1 GENERATED ALWAYS 示例

```sql
CREATE TABLE employees (
    emp_id BIGINT GENERATED ALWAYS AS IDENTITY,
    name TEXT NOT NULL,
    PRIMARY KEY (emp_id)
);

-- 正常插入（由系统生成ID）
INSERT INTO employees (name) VALUES ('张三');

-- 尝试手动指定ID会报错
INSERT INTO employees (emp_id, name) VALUES (100, '李四');
-- 错误: 无法插入到列"emp_id"
```

### 3.2 GENERATED BY DEFAULT 示例

```sql
CREATE TABLE employees (
    emp_id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    PRIMARY KEY (emp_id)
);

-- 由系统生成ID
INSERT INTO employees (name) VALUES ('张三');

-- 也可以手动指定ID
INSERT INTO employees (emp_id, name) VALUES (100, '李四');
```

### 3.3 使用 OVERRIDING SYSTEM VALUE

对于 GENERATED ALWAYS 列，如果需要手动指定值，可以使用：

```sql
INSERT INTO employees (emp_id, name)
OVERRIDING SYSTEM VALUE
VALUES (100, '李四');
```

## 4. 身份列(IDENTITY)与序列(SEQUENCE)的关系

`GENERATED AS IDENTITY` 本质上是 PostgreSQL 对标准 SQL 身份列的实现，底层仍然使用序列：

```sql
-- 查看关联的序列
SELECT pg_get_serial_sequence('employees', 'emp_id');

-- 获取当前值
SELECT currval(pg_get_serial_sequence('employees', 'emp_id'));
```

## 5. 修改 GENERATED 属性

可以修改现有列的生成属性：

```sql
-- 从 BY DEFAULT 改为 ALWAYS
ALTER TABLE employees 
ALTER COLUMN emp_id SET GENERATED ALWAYS;

-- 从 ALWAYS 改为 BY DEFAULT
ALTER TABLE employees 
ALTER COLUMN emp_id SET GENERATED BY DEFAULT;
```

## 6. 删除 GENERATED 属性

```sql
ALTER TABLE employees 
ALTER COLUMN emp_id DROP IDENTITY;
```

## 7. 实际应用建议

1. **优先使用 GENERATED ALWAYS**：除非有特殊需求，否则推荐使用更严格的 `ALWAYS` 选项
2. **数据迁移场景**：当需要导入已有数据时，可以使用 `BY DEFAULT` 或 `OVERRIDING SYSTEM VALUE`
3. **主键生成**：这是 `GENERATED AS IDENTITY` 最常见的应用场景

PostgreSQL 的 `GENERATED` 语法提供了符合 SQL 标准的自增列实现方式，比传统的 `SERIAL` 类型更符合标准且功能更完整。




# PostgreSQL 中的 GENERATED ALWAYS 语法详解

`GENERATED ALWAYS` 是 PostgreSQL 中用于定义生成列(generated columns)的语法，这些列的值由其他列的值自动计算得出，而不是直接存储。

## 1. 基本语法

```sql
CREATE TABLE table_name (
    column_name data_type 
    GENERATED ALWAYS AS (generation_expression) STORED
);
```

## 2. 两种生成列类型

PostgreSQL 支持两种生成列：

### 2.1 STORED 生成列

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    price NUMERIC(10,2),
    quantity INTEGER,
    total_value NUMERIC(12,2) GENERATED ALWAYS AS (price * quantity) STORED
);
```

插入数据示例：
```sql
INSERT INTO products (name, price, quantity) 
VALUES ('笔记本电脑', 5999.00, 3);
```

查询结果：
```
 id |     name      | price  | quantity | total_value 
----+---------------+--------+----------+-------------
  1 | 笔记本电脑   | 5999.00|        3 |    17997.00
```

### 2.2 VIRTUAL 生成列 (PostgreSQL 14+)

```sql
CREATE TABLE circles (
    id SERIAL PRIMARY KEY,
    radius NUMERIC,
    circumference NUMERIC GENERATED ALWAYS AS (2 * PI() * radius) STORED,
    area NUMERIC GENERATED ALWAYS AS (PI() * radius^2) STORED
);
```

## 3. 使用场景示例

### 3.1 计算完整姓名

```sql
CREATE TABLE customers (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    full_name VARCHAR(101) GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED
);
```

### 3.2 JSON 数据提取

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    order_data JSONB,
    customer_id INTEGER GENERATED ALWAYS AS ((order_data->>'customer_id')::INTEGER) STORED,
    order_date DATE GENERATED ALWAYS AS ((order_data->>'date')::DATE) STORED
);
```

### 3.3 条件计算

```sql
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    base_salary NUMERIC(10,2),
    bonus_rate NUMERIC(5,2),
    total_salary NUMERIC(10,2) GENERATED ALWAYS AS (
        base_salary * (1 + COALESCE(bonus_rate, 0))
    ) STORED
);
```

## 4. 修改生成列

```sql
-- 添加生成列
ALTER TABLE employees 
ADD COLUMN tax NUMERIC(10,2) GENERATED ALWAYS AS (total_salary * 0.2) STORED;

-- 不能直接修改生成列表达式，需要先删除再添加
ALTER TABLE employees DROP COLUMN tax;
ALTER TABLE employees 
ADD COLUMN tax NUMERIC(10,2) GENERATED ALWAYS AS (total_salary * 0.25) STORED;
```

## 5. 注意事项

1. 生成列不能直接写入或更新：
   ```sql
   -- 会报错
   UPDATE products SET total_value = 10000 WHERE id = 1;
   ```

2. 生成表达式只能引用同一表中的其他列

3. 生成表达式不能引用其他生成列（除非是同一CREATE TABLE语句中后面定义的列）

4. 生成表达式不能包含子查询或聚合函数

5. 生成表达式不能引用系统列（如oid）

6. 生成列可以有约束和索引

## 6. 与触发器的比较

生成列提供了比触发器更简单、更高效的自动计算列值的方式，但功能不如触发器灵活：
```
| 特性 | 生成列 | 触发器 |
|------|--------|--------|
| 性能 | 更高 | 较低 |
| 复杂度 | 简单 | 复杂 |
| 灵活性 | 有限 | 高 |
| 维护 | 容易 | 较难 |
| 跨表引用 | 不支持 | 支持 |
```
## 7. 系统视图信息

可以通过以下系统视图查看生成列信息：

```sql
SELECT 
    column_name, 
    is_generated, 
    generation_expression 
FROM information_schema.columns 
WHERE table_name = 'products';
```

示例输出：
```
 column_name | is_generated |     generation_expression      
-------------+--------------+---------------------------------
 id          | NEVER        | 
 name        | NEVER        | 
 price       | NEVER        | 
 quantity    | NEVER        | 
 total_value | ALWAYS       | (price * quantity)::numeric(12,2)
```